### 1. Interceptor와 Filter를 아시나요?

인터셉터(Interceptor)는 J2EE 표준 스펙인 필터(Filter)와 달리 Spring이 제공하는 기술로써, 디스패처 서블릿(Dispatcher Servlet)이 컨트롤러를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공한다. 즉, 웹 컨테이너(서블릿 컨테이너)에서 동작하는 필터와 달리 인터셉터는 스프링 컨텍스트에서 동작을 하는 것이다.


필터(Filter)는 J2EE 표준 스펙 기능으로 디스패처 서블릿(Dispatcher Servlet)에 요청이 전달되기 전/후에 url 패턴에 맞는 모든 요청에 대해 부가작업을 처리할 수 있는 기능을 제공한다. 디스패처 서블릿은 스프링의 가장 앞단에 존재하는 프론트 컨트롤러이므로, 필터는 스프링 범위 밖에서 처리가 되는 것이다. 즉, 스프링 컨테이너가 아닌 톰캣과 같은 웹 컨테이너(서블릿 컨테이너)에 의해 관리가 되는 것이고(스프링 빈으로 등록은 된다)

#### 언제 Interceptor를 사용하고 언제 Filter를 사용해야 할까요?

- 필터에서는 기본적으로 스프링과 무관하게 전역적으로 처리해야 하는 작업들을 처리
- 인터셉터에서는 클라이언트의 요청과 관련되어 전역적으로 처리해야 하는 작업

대표적으로 필터(Filter)를 인증과 인가에 사용하는 도구로는 SpringSecurity가 있다. SpringSecurity의 특징 중 하나는 Spring MVC에 종속적이지 않다는 것인데, 이러한 이유로는 필터 기반으로 인증/인가 처리를 하기 때문

### 2. DTO? DAO? VO?

- **DTO(Data Transfer Object)** : DTO는 계층간(Controller, View, Business Layer) 데이터 교환을 위한 자바 빈즈(Java Beans)를 의미한다.로직을 가지지 않는 데이터 객체이고 getter/setter메소드만 가진 클래스를 의미한다.
- **DAO(Data Access Object)** : DAO는 DB의 data에 접근하기 위한 객체로 직접 DB에 접근하여 데이터를 삽입, 삭제, 조회 등 조작할 수 있는 기능을 수행
  - DataBase 접근을 하기 위한 로직과 비지니스 로직을 분리하기 위해 사용한다.
- **VO(Value Object)** : DTO와 달리 VO는 Read-Only속성을 값 오브젝트이다. 자바에서 단순히 값 타입을 표현하기 위해 불변 클래스(Read-Only)를 만들어 사용한다.
  - VO의 핵심 역할은 equals()와 hashcode() 를 오버라이딩 하는 것이다. VO 내부에 선언된 속성(필드)의 모든 값들이 VO 객체마다 값이 같아야, 똑같은 객체라고 판별한다.

#### Repository와 DAO의 차이를 아시나요?
대체로 DAO는 DB 테이블과 1대1 매핑을 시킵니다.
Repository는 연관이 있고, 함께 변경되어야 하는 여러 도메인 모델 사이에서, 이들의 진입점 역할을 할 수 있는 도메인 엔티티에 대해서만 Repository를 구현합니다.

#### DTO와 VO는 무엇이 다를까요?
- DTO (Data Transfer Object)
  - 계층 간 데이터 전달
  - 필드 값이 같아도 서로 다른 객체
  - setter 존재 시 가변, 아니면 불변
  - getter/setter 외의 로직은 필요없음
- VO
  - 값 자체를 표현
  - 필드값이 같으면 같은 객체
  - 불변
  - getter/setter 외의 로직이 있어도 됨

### 3. Annotation은 무엇일까요?
자바 애너테이션(Java Annotation)은 자바 소스 코드에 추가하여 사용할 수 있는 메타데이터의 일종이다. 보통 @ 기호를 앞에 붙여서 사용한다. JDK 1.5 버전 이상에서 사용 가능하다. 자바 애너테이션은 클래스 파일에 임베디드되어 컴파일러에 의해 생성된 후 자바 가상머신에 포함되어 작동한다.

#### Java의 Annotation과 Python의 Decorator를 비교해 봅시다!
| 요소                  | Java Annotation                         | Python Decorator                                |
|-----------------------|----------------------------------------|------------------------------------------------|
| **역할**               | 메타데이터 제공, 실행 전 직접적인 기능 없음 | 함수/클래스의 동작을 변경하거나 기능 추가       |
| **구현 방식**          | 주로 `@interface`로 정의               | 함수나 클래스, 또는 함수 반환 함수로 정의       |
| **적용 대상**          | 클래스, 메서드, 필드                   | 함수, 메서드, 클래스                           |
| **실행 시점**          | 런타임에 리플렉션으로 해석             | 함수 호출 시점에 실행                          |
| **직접적인 동작 수정** | 자체적으로 동작을 수정하지 않음        | 동작을 직접 수정 가능                          |
| **사용 목적**          | 코드 가독성 및 프레임워크 설정         | 로직 확장 및 동작 변경                         |

### 4. HTTP/1.1, HTTP/1.2, HTTP2, HTTP3의 차이를 아시나요?
| 특징                   | HTTP/1.1                             | HTTP/2                              | HTTP/3                         |
|------------------------|--------------------------------------|-------------------------------------|---------------------------------|
| **기반 프로토콜**      | TCP                                  | TCP                                 | UDP (QUIC)                      |
| **멀티플렉싱**         | 지원하지 않음                        | 지원                                | 지원                            |
| **헤더 압축**          | 지원하지 않음                        | HPACK                              | QPACK                           |
| **서버 푸시**          | 지원하지 않음                        | 지원                                | 지원                            |
| **헤드-오브-라인 블로킹** | 있음                                | 있음 (TCP 특성상)                  | 없음                            |
| **암호화**             | 선택 사항                            | 선택 사항                           | 기본 내장 (TLS 1.3)             |


### 5. Non-blocking vs Multi-threading. 둘의 용법은 어떻게 다를까요?
- Multi-threading은 여러 스레드를 통해 병렬로 작업을 처리하며, CPU 성능을 최대한 활용할 수 있습니다. 하지만 각 스레드가 I/O 작업에서 대기할 경우, 블로킹으로 인해 효율이 떨어질 수 있습니다.
- Non-blocking I/O는 작업을 비동기 방식으로 처리하여 하나의 스레드가 여러 작업을 효율적으로 처리할 수 있습니다. 특히, 네트워크와 파일 시스템의 I/O 작업에 적합하며, 확장성이 높아 많은 클라이언트를 동시에 처리할 수 있습니다.

따라서, Multi-threading은 CPU를 최대한 활용한 병렬 처리에 적합하며, Non-blocking I/O는 대기 시간이 긴 I/O 작업에서 성능을 최적화하는 데 유리합니다.