# chapter 3. 코드에서 나는 악취 (Code Smells)

리팩터링을 언제 시작하고 언제 그만할지를 판단하는 일은 리팩터링의 작동 원리를 아는 것 못지않게 중요하다.

이 책의 공동저자인 켄트 벡은 리팩터링할 '시점'을 설명하는 데 '**냄새(smell)**'이라는 표현을 사용했다.

### 1. 기이한 이름

코드를 명료하게 표현하는 데 가장 중요한 요소는 **이름**이다. 좋은 코드는 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 엄청나게 신경 써서 이름을 지어야한다.

- **함수 선언 바꾸기**
- **변수 이름 바꾸기**
- **필드 이름 바꾸기**

### 2. 중복 코드

똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다.

- **함수 추출하기**: 양쪽 모두 추출된 메서드를 사용
- **문장 슬라이스하기**: 비슷한 부분을 한 곳에 모아 함수 추출하기를 더 쉽게 적용할 수 있는지 봄
- **메서드 올리기**: 같은 부모로부터 파생된 서브클래스들에 코드가 중복되어 있는 경우 부모로 코드를 옮김

### 3. 긴 함수

오랜 기간 잘 활용되는 프로그램들은 하나같이 짧은 함수로 구성된다.

**간접 호출(indirection)**의 효과, 코드를 이해하고 공유하고 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 가능하다.

짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 **좋은 이름**이다. 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다.

- **함수 추출하기**
- 매개변수와 임시변수는 코드를 이해하기 어렵게 만든다.
  - **임시 변수를 질의 함수로 바꾸기**: 임시 변수의 수를 줄인다
  - **매개변수 객체 만들기**, **객체 통째로 넘기기**: 매개 변수의 수를 줄인다
- **함수를 명령으로 바꾸기**: 매개변수와 임시변수가 너무 많을 때
- **조건문 분해하기**
- **조건부 로직을 다형성으로 바꾸기**
- **반복문 쪼개기**

### 4. 긴 매개변수 목록

매개변수 목록이 길어지면 그 자체로 이해하기 어려운 때가 많다. 

- **매개변수를 질의 함수로 바꾸기**: 다른 매개변수에서 값을 얻어올 수 있는 경우
- **객체 통째로 넘기기**: 객체에서 몇개를 뽑아서 전달하는 것보다 모두 묶어서 전달
- **매개변수 객체 만들기**: 여러 매개변수를 하나의 객체로 묶어버리기
- **플래그 인수 제거하기**: 함수의 동작 방식을 정하는 플래그 역할의 매개변수는 제거
- **여러 함수를 클래스로 묶기**: 고정 값들을 클래스의 필드로 정의

### 5. 전역 데이터

전역 데이터를 주의해아 한다는 말은 소프트웨어 개발을 시작한 초창기부터 항상 들었던 말이다.

- **변수 캡슐화하기**: 오염시킬 가능성이 있는 데이터를 발견할 때마다 이 기법을 가장 먼저 적용용

### 6. 가변 데이터

가변 데이터는 프로그램이 진행함에 따라 코드가 수정되면 값은 바뀐다.

- **변수 캡슐화하기**: 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 변경
- **변수 쪼개기**: 용도별로 독립 변수에 저장하게 하여 값 갱신이 문제를 일으킬 여지를 줄임
- **문장 슬라이드하기**, **함수 추출하기**: 무언가를 갱신하는 코드로부터 부작용이 없는 코드를 분리
- **질의 함수와 변경 함수 분리하기**: 꼭 필요한 경우가 아니라면 부작용이 있는 코드를 호출할 수 없게함
- **세터 제거하기**
- **파생 변수를 질의 함수로 바꾸기**
- **여러 함수를 클래스로 묶기**, **여러 함수를 변환 함수로 묶기**: 변수를 갱신하는 코드의 제한
- **참조를 값으로 바꾸기**

### 7. 뒤엉킨 변경

단일 책임 원칙이 제대로 지켜지지 않을 때 밀접한 부분의 여러 클래스를 수정해야하는 일이 빈번해진다. 하나의 모듈이 이런저런 이유로 계속해서 수정되어야 하는 경우이다.

- **단계 쪼개기**
- **함수 옮기기**
- **함수 추출하기**
- **클래스 추출하기**

### 8. 산탄총 수술

코드를 변경할 떄마다 자잘하게 수정해야하는 클래스가 많을 때 풍긴다.

- **함수 옮기기, 필드 옮기기**: 함께 변경되는 대상들을 한 모듈에 두기 
- **여러 함수를 클래스로 묶기**: 비슷한 데이터를 다루는 함수가 많다면
- **함수 인라인하기, 클래스 인라인하기**: 어설프게 분리된 로직을  같은 인라인 리팩터링으로 고치기

### 9. 기능 편애

어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할 일이 더 많을 때 풍기는 냄새

- **함수 옮기기**: 데이터 근처로 함수를 옮김

### 10. 데이터 뭉치

여러 클래스의 필드에서, 또는 여러 메서드의 시그니처에서 몰려다니는 데이터들은 하나로 묶어주는 것이 마땅하다
  
### 11. 기본형 집착

전화번호와 같은 문자열 집합을 기본형 객체인 `String`을 쓰는 것보다 객체로 바꾸면 어떨까?

### 12. 반복되는 `Switch` 조건문

중복된 `Switch`문이 문제가 되는 이유는 조건절을 하나 추가할 때마다 다른 조건문도 함께 수정해야하기 때문이다. 이럴 때는 다형성을 이용하면 잘 해결할 수 있다.

### 13. 반복문

**반복문을 파이프라인으로 바꾸기**: 일급 함수를 사용하여 코드를 작성하면 가독성이 더 좋다. (특히, `filter`, `map` 함수)

### 14. 성의없는요소

우리는 코드의 구조를 잡을 때 프로그램 요소(클래스, 인터페이스, 메서드)를 이용하는 것을 좋아한다. 하지만 필요없는 내용에서는 이런 부분은 삭제하는 것이 좋다.

### 15. 추측성 일반화

'나중에 필요할 거야' 라는 생각으로 당장은 필요없는 모든 종류의 후킹 포인트와 특이 케이스 처리 로직을 작성해둔 코드에서 발생한다. 그 결과는 이해하거나 관리하기 어려운 코드이므로 삭제하는 것이 좋다.

### 16. 임시 필드

특정 상황에서만 값이 설정되는 필드를 가진 클래스도 종종 존재한다. 임시 필드를 갖ㄱ도록 작성하면 코드를 이해하기 어렵다.

- **클래스 추출하기, 함수 옮기기**
- **특이 케이스 추가하기**

### 17. 메시지 체인

다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드에서 발생한다.

- **위임 숨기기**를 이용해서 해결한다.

### 18. 중개자

객체의 대표적인 기능 하나로 외부로부터 세부사항을 숨겨주는 캡슐화가 있다.

캡슐화하는 과정에서는 위임이 많이 사용된다.

그러다보면 지나치게 클래스의 기능들이 다른 클래스로 위임될 수 있다. 

이럴때는 **중개자 제거하기**를 사용하여 소통하게 할 수 있다.

### 19. 내부자 거래

모듈사이의 거래가 많으면 결합도가 높다고 한다. 그 양을 최소로 줄이고 모두 투명하게 처리해야한다.

### 20. 거대한 클래스

한 클래스가 너무 많은 일을 하려다보면 필드 수가 상당히 늘어난다.

- **클래스 추출하기**: 필드 일부를 따로 묶는다.
- **타입 코드를 서브 클래스로 바꾸기**: 하위 클래스로 변경한다.


