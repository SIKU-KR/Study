chapter 9. 데이터 조직화

### 9.1 변수 쪼개기

변수는 다양한 용도로 쓰인다.
긴 코드의 결과를 저장했다가 나중에 쉽게 참조하려는 목적으로 흔히 쓰이는 변수는 값을 단 한번만 대입해야한다. (`const` 선언 필요)

역할이 둘 이상인 변수가 있다면 쪼개야 한다. 예외는 없다.

1. 변수를 선언한 곳과 값을 처음 대입하는 곳에서 변수 이름을 바꾼다. 
	1. 가능하면 이때 불변 변수로 선언한다
2. 이 변수에 두 번째로 값을 대입하는 곳 앞까지의 모든 참조를 새로운 변수로 바꾼다.
3. 두 번째 대입 시 변수를 다시 원래 이름으로 선언한다.
4. 테스트한다.
5. 모두 변할 때까지 반복한다.

> 변수를 처음 사용하는 곳을 바꾸고 그 이후에 대입되는 시점부터의 변수는 냅둔다.

### 9.2 필드 이름 바꾸기

이름은 데이터를 이해하는데에 큰 역할을 하므로 반드시 깔끔하게 관리해야 한다.

> IDE의 자동 리팩터링 기능을 사용한다.

### 9.3 파생 변수를 질의 함수로 바꾸기

```javascript
get discounted() { return this._baseTotal - this._discount; }
```

가변 데이터는 소프트웨어에 문제를 일으키는 가장 큰 골칫 덩이에 속한다.
서로 다른 두 코드를 이상한 방식으로 결합하기도 하는데, 
**한 쪽 코드에서 수정한 값이 연쇄 효과를 일으켜 다른 쪽 코드에 원인을 찾기 어려운 문제**를 야기하기도 한다.

1. 변수 값이 갱신되는 지점을 모두 찾는다. 필요하면 **변수 쪼개기**를 이용해서 모두 분리한다.
2. 해당 변수의 값을 계산하는 함수를 만든다.
3. 해당 변수가 사용되는 모든 곳에 `Assertions`를 추가하여 함수의 계산 결과가 변수의 값과 같은지 확인한다.
4. 테스트한다.
5. 변수를 읽는 코드를 함수 호출로 바꾼다.
6. 테스트한다.

### 9.4 참조를 값으로 바꾸기

```javascript
class Product {
	applyDiscount(arg) {
		this._price = new Money(this._price.amount - arg, this._price.currency);
	}
}
```

객체를 다른 객체에 중첩하면 내부 객체를 참조 혹은 값으로 취급 할 수 있다. 내부 객체의 속성을 갱신하는 방식에서 가장 극명하게 드러난다.

필드를 값으로 다룬다면 내부 객체의 클래스를 수정하여 **값 객체**(Value Object)로 만들 수 있다. 이는 좋은데, **불변이기 때문**이다.

**값 객체**를 사용하면 서로 간의 참조를 관리하지 않아도 된다. 따라서 분산 시스템과 동시성 시스템에서 유용하다.

1. 후보 클래스가 불변인지, 혹은 불변이 될 수 있는지 확인한다.
2. 각각의 **setter 메서드를 제거**한다.
3. 값 객체 **필드들을 사용하는 동치성(`isEqual`, `hashcode` 등)의 비교 메서드**를 만든다.

### 9.5 값을 참조로 바꾸기

논리적으로 같은 데이터를 물리적으로 복제해 사용할 때 가장 크게 문제되는 상황은 그 데이터를 갱신해야 할 때다.
모든 **복제본을 찾아서 빠짐없이 갱신**해야하며, **쉽게 일관성이 깨져버린**다. 이런 상황에서는 값 객체로 가지고 있기보단, 참조를 사용하자.

1. 같은 부류에 속하는 객체들을 보관할 저장소를 만든다.
2. 생성자에서 이 부류의 객체들 중 특정 객체를 정확히 찾아내는 방법이 있는지 확인한다.
3. 호스트 객체의 생성자들을 수정하여 필요한 객체를 이 저장소에서 찾도록 한다.

### 9.6 매직 리터럴 바꾸기

```javascript
const STANDARD_GRAVITY = 9.81;
function potentialEnergy(mass, height) {
	return mass * STANDARD_GRAVITY * height;
}
```

매직 리터럴이란 소스 코드에 등장하는 일반적인 리터럴 값을 말한다.
의미를 알고 있다고 해도 결국 각자의 머리에서 해석해낸 것일 뿐이라서, 이보다는 코드 자체가 뜻을 분명하게 드러내는것이 좋다.

