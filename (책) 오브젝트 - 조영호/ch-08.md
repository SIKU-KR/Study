# Chapter 08. 의존성 관리하기

### 의존성 이해하기

- 작고 응집도 높은 객체는 책임의 초점이 명확하고 한 가지 일만 잘하는 객체를 의미한다.
    
- 이러한 객체는 단독으로는 작업을 수행하기 어렵기 때문에 다른 객체와의 협력이 필요하다.
    
- 그러나 과도한 협력은 과도한 의존성을 초래하며, 이는 애플리케이션을 변경하기 어렵게 만든다.
    
- 객체 지향 설계는 의존성을 관리하고, 객체가 변화를 수용할 수 있도록 의존성을 정리하는 기술이다.
    

### 변경과 의존성

- **실행 시점 의존성** : 객체가 동작하기 위해 실행 시점에 의존 대상이 필요한 것을 의미한다.
    
- **구현 시점 의존성** : 의존 대상 객체가 변경되면 의존 객체도 변경되는 것을 의미한다.
    
- 의존성은 항상 단방향성을 가진다.
    
- **의존성 전이** : 객체 A가 객체 B를 의존할 때, A는 B가 의존하는 객체 C에 대해서도 의존하는 현상이다.
    
- 객체의 캡슐화는 변경의 전파를 막아 의존성 전이를 억제한다.
    
- 직접 의존성과 간접 의존성의 차이는 클래스에 필드로 명시된 의존 여부이다.
    

### 런타임 의존성과 컴파일 의존성

- **컴파일 의존성** : 코드 작성 시점의 의존성을 의미한다.
    
- **런타임 의존성** : 실행 시점의 의존성을 의미하며, 컴파일 의존성을 런타임 의존성으로 대체해야 한다.
    
- 유연하고 재사용 가능한 설계를 위해서는 동일한 소스 코드 구조로 다양한 실행 구조를 만들 수 있어야 한다.
    
- 시스템의 실행 시점 구조는 설계자가 정의한 타입 간의 관계로 구성되므로, 객체와 타입 간의 관계를 잘 정의해야 한다.
    

### 컨텍스트 독립성

- 클래스가 특정 문맥에 대한 최소한의 가정만 하도록 설계되면 다른 문맥에서 재사용하기 용이해진다.
    
- 유연한 설계를 위해서는 실행될 컨텍스트에 대한 구체적인 정보를 가능한 한 적게 알아야 한다.
    

### 의존성 해결하기

- 런타임 실행 컨텍스트에 맞는 적절한 의존성으로 교체하는 것을 의존성 해결이라고 한다.
    
- 의존성 해결 방법으로는 생성자, Setter, 메서드 인자 전달 등이 있다.
    
- Setter를 통한 의존성 해결은 객체 생성 후 의존 대상을 설정하므로 객체 상태가 불안정할 수 있으며, NPE 발생의 우려가 있다.
    

### 의존성과 결합도

- 과도한 의존성은 문제를 일으킬 수 있으며, 추상화 레이어를 통해 컴파일 시점의 의존성을 관리하고 런타임에 구체 클래스에 의존하도록 변경할 수 있다.
    
- 바람직한 의존성은 재사용 가능하고 컨텍스트에 독립적인 설계를 지향한다.
    
- 잘못된 의존성은 재사용을 위해 내부 구현을 변경해야 하는 의존성이다.
    
- 한 요소가 다른 요소에 대해 더 많은 정보를 알수록 두 요소는 강하게 결합되며, 추상화를 통해 정보 은닉을 하면 결합도를 낮출 수 있다.
    

### 추상화에 의존하라

- 추상 클래스나 인터페이스는 내부 구현과 종류에 대한 지식을 숨길 수 있다.
    
- 인터페이스는 상속 계층에 대한 지식이 없어도 협력이 가능하므로, 의존 대상이 추상적일수록 결합도는 낮아진다.
    
- 인스턴스 변수 타입을 추상 클래스나 인터페이스 타입으로 선언하고, 생성자를 통해 인스턴스를 주입하여 의존성을 해결하며, 생성 책임은 다른 곳으로 위임한다.
    
- 인터페이스를 통해 추상화 타입을 노출하는 것을 명시적 의존성이라 하며, 클래스 내부에서 생성하는 숨겨진 의존성은 지양해야 한다.
    

### new는 해롭다

- new를 사용하면 구체 클래스에 의존하게 되며, 생성자 호출에 필요한 인자 정보까지 알아야 하므로 클라이언트의 지식이 증가한다.
    
- 해결 방법은 인스턴스 생성 로직과 사용 로직을 분리하는 것이며, 객체는 외부에서 생성된 인스턴스를 전달받아 사용만 해야 한다.