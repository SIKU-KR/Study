# Chapter 06. 메시지와 인터페이스
대부분의 입문자들은 분석, 설계, 구현을 아우르는 전체 개발 활동의 중심에 클래스를 둔다. 
하지만 클래스는 도구일 뿐이다. 구현 도구에 지나치게 집착하면 **경직되고 유연하지 못한 설계에 이를 확률이 높아진다**.

훌륭한 객체지향 코드를 얻기 위해서는 클래스가 아니라 객체를 지향해야 한다.
객체 지향 애플리케이션의 가장 중요한 재료는 **객체들이 주고받는 메시지**이다. 
이 챕터에서는 좋은 퍼블릭 인터페이스를 얻는 방법을 설명한다.

### 용어 정의
| 용어 | 정의 |
| :-- | :-- |
| 메시지 | 객체가 다른 객체와 협력하기 위해 사용하는 의사소통 메커니즘. 메시지 전송은 전송자와 수신자 모두를 포함한다. |
| 오퍼레이션 | 객체가 다른 객체에게 제공하는 추상적인 서비스. 메시지 수신시 객체의 오퍼레이션을 호출하는 것을 의미한다. |
| 메서드 | 메시지에 응답하기 위해 실행되는 코드 블록. 오퍼레이션의 구현이며, 동일한 오퍼레이션이라도 메서드는 다를 수 있다. |
| 퍼블릭 인터페이스 | 객체가 외부에서 수신할 수 있도록 공개한 메시지의 묶음. 객체 설계 시 중요한 요소. |
| 시그니처 | 오퍼레이션이나 메서드의 이름과 인자 목록을 나타낸 것. 일부 언어에서는 반환 타입도 시그니처에 포함된다. |

### 클라이언트 서버 모델
협력은 어떤 객체가 다른 객체에게 무언가를 요청할 때 시작된다. 
객체가 다른 객체에게 접근할 수 있는 유일한 방법은 메시지를 전송하는 것 뿐이다.
이 관계를 설명하기 위해 전통적으로 **클라이언트-서버 모델**을 사용한다.
![](attachment/a05a23a68224333b01863e41f7f0cf09.png)

객체는 협력에 참여하는 동안 클라이언트와 서버의 역할을 **동시에 수행하는 것이 일반적**이다.

협력의 관점에서 객체는 두 가지 종류의 메시지 집합으로 구성된다.
- 객체가 수신하는 메시지의 집합
- 외부의 객체에게 전송하는 메시지의 집합

### 인터페이스와 설계 품질

좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스 라는 조건을 만족해야한다.

- 최소한의 인터페이스 : 꼭 필요한 오퍼레이션만 포함해야한다.
- 추상적인 인터페이스 : 어떻게 수행하는지와 무엇을 하는지를 표현해야한다.

이를 실현하기 위한 4가지 법칙을 소개한다.

- 디미터 법칙
- 묻지 말고 시켜라
- 의도를 드러내는 인터페이스
- 명령-쿼리 분리

### 디미터 법칙
디미터 법칙은 협력하는 객체의 **내부 구조에 대한 결합으로 인해 발생하는 설계 문제**를 해결하기 위해 제안된 원칙이다.
*"낯선 자에게 말하지 말라"* 또는 *"오직 인접한 이웃하고만 말하라"* 로 요약할 수 있다고 한다.

이 법칙을 따르기 위해서는 클래스가 아래의 특정한 조건을 만족하는 대상에게만 메시지를 전송하도록 프로그래밍 해야한다.
- `this` 객체
- 메서드의 매개변수
- `this`의 속성
- `this`의 속성인 컬렉션의 요소
- 메서드 내에서 생성된 지역 객체

디미터 법칙은 캡슐화를 다른 관점에서 표현한것으로, 클래스를 캡슐화하기 위해 따라야하는 구체적인 지침을 제공하기 때문이다.

```java
// 디미터 법칙을 위반하는 코드의 전형적인 모습
screening.getMovie().getDiscountConditions();
```

이와 같은 코드를 기차 충돌이라고 부르는데 여러 대의 기차가 한줄로 늘어서 충돌한 것처럼 보이기 때문이다.

#### 이 원칙의 함정 : 디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다.
아래 코드는 기차충돌 처럼 보일 수 있다.
```java
long result = IntStream.of(1, 15, 20, 3, 9)
                       .filter(x -> x > 10)
                       .distinct()
                       .count();
```
IntStream은 불변(immutable)이어서 `.filter()`, `.distinct()` 같은 중간 연산을 호출할 때마다 해당 연산이 추가된 **새로운** 스트림 객체를 반환한다. 
디미터 법칙은 결합도와 관련된 것이며, 객체의 내부 구조가 외부로 노출되는 경우로 한정한다.
### 묻지 말고 시켜라

디미터 법칙은 훌륭한 메시지는 객체에 상태에 관해 묻지 말고 원하는 것을 시켜야 한다는 것을 강조한다.
이는 자연스럽게 **정보 전문가**에게 책임을 할당하게 되고 높은 응집도를 가진 클래스를 얻을 확률이 높아진다.

#### 이 원칙의 함정 : 가끔씩은 묻는 것 외에는 다른 방법이 존재하지 않는 경우도 존재한다.
대표적으로 컬렉션에 포함된 객체들을 처리하는 유일한 방법은 객체에게 물어보는 것이다.
```java
for(Movie each : movies){
	total += each.getFee();
}
```
### 의도를 드러내는 인터페이스

어떻게 하느냐가 아니라 무엇을 하는냐에 초점을 맞춰서 메서드의 이름을 짓는 것을 **의도를 드러내는 선택자**라고 부른다.

> 하나의 구현을 가진 메시지의 이름을 일반화하도록 도와주는 간단한 방법은, 매우 다른 두번째 구현을 상상하고 해당 메서드에 동일한 이름을 붙인다고 상상해보라. 그때 가장 추상적인 이름을 메서드에 붙일 것 이다. 
> - 켄트벡 

객체에게,,
1. 묻지 말고 시키되,
2. 구현 방법이 아닌 클라이언트의 의도를 드러내야 한다.

### 명령-쿼리 분리

이 원칙은 퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고할 수 있는 지침을 제공한다.

어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈을 **루틴(routine)** 이라고 부른다.
루틴은 다시 프로시저와 함수로 구분할 수 있다.
- **프로시저**는 부수효과를 발생시킬 수 있지만 값을 반환할 수 없다
- **함수**는 값을 반환할 수 있지만 부수효과를 발생시킬 수 없다.

명령(Command)와 쿼리(Query)는 프로시저와 함수를 부르는 또 다른 이름이다.
- 객체의 상태를 수정하는 오퍼레이션을 프로시저라고 부름
- 객체와 관련된 정보를 반환하는 오퍼레이션을 쿼리라고 부름

명령과 쿼리를 뒤섞으면 실행 결과를 예측하기가 어려워질 수 있다.
이 결과로는 이해하기 어렵고 잘못 사용하기 쉬우며 버그를 양산하는 경향이 있다.
### 결론: 책임에 초점을 맞춰라

위에 내용을 모두 따르면서 좋은 인터페이스를 작성하는 방법이 있다. 

> 메시지를 먼저 선택하고 그 후에 메시지를 처리할 객체를 선택하는 것이다

이 방식을 적용할 때 얻는 이점은 다음과 같다:

- **디미터 법칙 준수**: 객체의 내부 구조를 몰라도 메시지를 선택해 설계할 수 있어 결합도를 낮출 수 있다.
    
- **문지 말고 시켜라**: 필요한 정보 요구 없이 원하는 작업을 바로 표현하는 메시지를 전달한다.
    
- **의도를 드러내는 인터페이스**: 클라이언트가 원하는 메시지를 명확히 표현하여 인터페이스를 직관적으로 만든다.
    
- **명령-쿼리 분리 원칙 강화**: 객체의 상태를 예측·이해하기 쉽도록 명령과 조회를 구분하는 설계를 하게 된다.